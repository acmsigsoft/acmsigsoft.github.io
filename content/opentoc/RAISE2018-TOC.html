
<!doctype html>
<head>
<META http-equiv="Content-Style-Type" content="text/css">
<title>RAISE '18- Proceedings of the 6th International Workshop on Realizing Artificial Intelligence Synergies in Software Engineering</title>
<STYLE type="text/css">
#DLtoc {
	font: normal 12px/1.5em Arial, Helvetica, sans-serif;
	}

#DLheader {
	}
#DLheader h1 {
	font-size:16px;	
}
	
#DLcontent {
	 font-size:12px;
	}
#DLcontent h2 {
	 font-size:14px;
	 margin-bottom:5px;
	}
#DLcontent h3 {
	 font-size:12px;
	 padding-left:20px;
	 margin-bottom:0px;
	}

#DLcontent ul{
	margin-top:0px;
	margin-bottom:0px;
	}
		
.DLauthors li{
	display: inline;
	list-style-type: none;
	padding-right: 5px;
	}
	
.DLauthors li:after{
	content:",";
	}
.DLauthors li.nameList.Last:after{
	content:"";
	}		

.DLabstract {
	 padding-left:40px;
	 padding-right:20px;
	 display:block;
	}

.DLformats li{
	display: inline;
	list-style-type: none;
	padding-right: 5px;
	}
	
.DLformats li:after{
	content:",";
	}
.DLformats li.formatList.Last:after{
	content:"";
	}		

.DLlogo {
	vertical-align:middle; 
	padding-right:5px;
	border:none;
	}
	
.DLcitLink {
	margin-left:20px;
	}	

.DLtitleLink {
	margin-left:20px;
	}	

.DLotherLink {
	margin-left:0px;
	}		
   
</STYLE>
</head>
<body>
<div id="DLtoc">
<div id="DLheader">
<h1>RAISE '18- Proceedings of the 6th International Workshop on Realizing Artificial Intelligence Synergies in Software Engineering</h1>
<a class="DLcitLink" href="https://urldefense.proofpoint.com/v2/url?u=https-3A__dl.acm.org_citation.cfm-3Fid-3D3194104&d=DwMFAg&c=clK7kQUTWtAVEOVIgvi0NU5BOUHhpN0H8p7CSfnc_gI&r=ZHuLpaRqk3Uz8lrvKUHs4g&m=91ndoZ1I-yPC2zXM6gqLhbohzFgiNgzLAyq0vrmbglM&s=i6PLD6BqUfH2uWvAzE270pdEWplHBs0oPssmZuX-QU8&e=" title="Go to the ACM Digital Library for additional information about this proceeding"><img class="DLlogo" src="https://dl.acm.org/img/dllogo.png" alt="Digital Library logo" height="30" width="30">Full Citation in the ACM Digital Library</a>
</div>
<div id="DLcontent">
<h2>SESSION: Natural language and text data</h2>
<div class="DLabstract"> </div>
<h3>
<a class="DLtitleLink" href="https://urldefense.proofpoint.com/v2/url?u=https-3A__dl.acm.org_authorize-3FN652174&d=DwMFAg&c=clK7kQUTWtAVEOVIgvi0NU5BOUHhpN0H8p7CSfnc_gI&r=ZHuLpaRqk3Uz8lrvKUHs4g&m=91ndoZ1I-yPC2zXM6gqLhbohzFgiNgzLAyq0vrmbglM&s=XXJFljKKtx88iot-TuTp1HzvAMJfaHmx_R6_vhvjouE&e=" title="Get the Full Text from the ACM Digital Library">Integrating a dialog component into a framework for spoken language understanding</a>
</h3>
<ul class="DLauthors">
<li class="nameList First">Sebastian Weigelt</li>
<li class="nameList">Tobias Hey</li>
<li class="nameList Last">Mathias Landh&#228;u&#223;er</li>
</ul>
<div class="DLabstract"><div style="display:inline"><p>Spoken language interfaces are the latest trend in human computer interaction. Users enjoy the newly found freedom but developers face an unfamiliar and daunting task. Creating reactive spoken language interfaces requires skills in natural language processing. We show how a developer can integrate a dialog component in a natural language processing system by means of software engineering methods. Our research project PARSE that aims at naturalistic end-user programming in spoken natural language serves as an example. We integrate a dialog component with PARSE without affecting its other components: We modularize the dialog management and introduce dialog acts that bundle a trigger for the dialog and the reaction of the system. We implemented three dialog acts to address the following issues: speech recognition uncertainties, coreference ambiguities, and incomplete conditionals.</p> <p>We conducted a user study with ten subjects to evaluate our approach. The dialog component achieved resolution rates from 23% to 50% (depending on the dialog act) and introduces a negligible number of errors. We expect the overall performance to increase even further with the implementation of additional dialog acts.</p></div> </div>
<h3>
<a class="DLtitleLink" href="https://urldefense.proofpoint.com/v2/url?u=https-3A__dl.acm.org_authorize-3FN652185&d=DwMFAg&c=clK7kQUTWtAVEOVIgvi0NU5BOUHhpN0H8p7CSfnc_gI&r=ZHuLpaRqk3Uz8lrvKUHs4g&m=91ndoZ1I-yPC2zXM6gqLhbohzFgiNgzLAyq0vrmbglM&s=Xpi-e7C2nrhLADaK7dYDB4xWPhjb6IKPY2ceXjAsV3s&e=" title="Get the Full Text from the ACM Digital Library">Exploring the benefits of utilizing conceptual information in test-to-code traceability</a>
</h3>
<ul class="DLauthors">
<li class="nameList First">Andr&#225;s Kicsi</li>
<li class="nameList">L&#225;szl&#243; T&#243;th</li>
<li class="nameList Last">L&#225;szl&#243; Vid&#225;cs</li>
</ul>
<div class="DLabstract"><div style="display:inline"><p>Striving for reliability of software systems often results in immense numbers of tests. Due to the lack of a generally used annotation, finding the parts of code these tests were meant to assess can be a demanding task. This is a valid problem of software engineering called test-to-code traceability. Recent research on the subject has attempted to cope with this problem applying various approaches and their combinations, achieving profound results. These approaches have involved the use of naming conventions during development processes and also have utilized various information retrieval (IR) methods often referred to as conceptual information. In this work we investigate the benefits of textual information located in software code and its value for aiding traceability. We evaluated the capabilities of the natural language processing technique called Latent Semantic Indexing (LSI) in the view of the results of the naming conventions technique on five real, medium sized software systems. Although LSI is already used for this purpose, we extend the viewpoint of one-to-one traceability approach to the more versatile view of LSI as a recommendation system. We found that considering the top 5 elements in the ranked list increases the results by 30% on average and makes LSI a viable alternative in projects where naming conventions are not followed systematically.</p></div> </div>
<h3>
<a class="DLtitleLink" href="https://urldefense.proofpoint.com/v2/url?u=https-3A__dl.acm.org_authorize-3FN652186&d=DwMFAg&c=clK7kQUTWtAVEOVIgvi0NU5BOUHhpN0H8p7CSfnc_gI&r=ZHuLpaRqk3Uz8lrvKUHs4g&m=91ndoZ1I-yPC2zXM6gqLhbohzFgiNgzLAyq0vrmbglM&s=_COlqHc45MHzcKCkKMxCqDH-xiG3Y76v5edUkRAgjMs&e=" title="Get the Full Text from the ACM Digital Library">Complementing machine learning classifiers via dynamic symbolic execution: "human vs. bot generated" tweets</a>
</h3>
<ul class="DLauthors">
<li class="nameList First">Sohil L. Shrestha</li>
<li class="nameList">Saroj Panda</li>
<li class="nameList Last">Christoph Csallner</li>
</ul>
<div class="DLabstract"><div style="display:inline"><p>Recent machine learning approaches for classifying text as human-written or bot-generated rely on training sets that are large, labeled diligently, and representative of the underlying domain. While valuable, these machine learning approaches ignore programs as an additional source of such training sets. To address this problem of incomplete training sets, this paper proposes to systematically supplement existing training sets with samples inferred via program analysis. In our preliminary evaluation, training sets enriched with samples inferred via dynamic symbolic execution were able to improve machine learning classifier accuracy for simple string-generating programs.</p></div> </div>
<h2>SESSION: Web data and taxonomy</h2>
<div class="DLabstract"> </div>
<h3>
<a class="DLtitleLink" href="https://urldefense.proofpoint.com/v2/url?u=https-3A__dl.acm.org_authorize-3FN652187&d=DwMFAg&c=clK7kQUTWtAVEOVIgvi0NU5BOUHhpN0H8p7CSfnc_gI&r=ZHuLpaRqk3Uz8lrvKUHs4g&m=91ndoZ1I-yPC2zXM6gqLhbohzFgiNgzLAyq0vrmbglM&s=EVKNhLdzKTt0w0wUMUdVM34l3mGk0l_rP3Ghiu5gUA4&e=" title="Get the Full Text from the ACM Digital Library">Codecatch: extracting source code snippets from online sources</a>
</h3>
<ul class="DLauthors">
<li class="nameList First">Themistoklis Diamantopoulos</li>
<li class="nameList">Georgios Karagiannopoulos</li>
<li class="nameList Last">Andreas L. Symeonidis</li>
</ul>
<div class="DLabstract"><div style="display:inline"><p>Nowadays, developers rely on online sources to find example snippets that address the programming problems they are trying to solve. However, contemporary API usage mining methods are not suitable for locating easily reusable snippets, as they provide usage examples for specific APIs, thus requiring the developer to know which library to use beforehand. On the other hand, the approaches that retrieve snippets from online sources usually output a list of examples, without aiding the developer to distinguish among different implementations and without offering any insight on the quality and the reusability of the proposed snippets. In this work, we present CodeCatch, a system that receives queries in natural language and extracts snippets from multiple online sources. The snippets are assessed both for their quality and for their usefulness/preference by the developers, while they are also clustered according to their API calls to allow the developer to select among the different implementations. Preliminary evaluation of CodeCatch in a set of indicative programming problems indicates that it can be a useful tool for the developer.</p></div> </div>
<h3>
<a class="DLtitleLink" href="https://urldefense.proofpoint.com/v2/url?u=https-3A__dl.acm.org_authorize-3FN652188&d=DwMFAg&c=clK7kQUTWtAVEOVIgvi0NU5BOUHhpN0H8p7CSfnc_gI&r=ZHuLpaRqk3Uz8lrvKUHs4g&m=91ndoZ1I-yPC2zXM6gqLhbohzFgiNgzLAyq0vrmbglM&s=IGJbGmshKK9Iqoill3YhrHDALTprzHU5Uchcru9qZjo&e=" title="Get the Full Text from the ACM Digital Library">Semi-automatic generation of active ontologies from web forms for intelligent assistants</a>
</h3>
<ul class="DLauthors">
<li class="nameList First">Martin Blersch</li>
<li class="nameList">Mathias Landh&#228;u&#223;er</li>
<li class="nameList Last">Thomas Mayer</li>
</ul>
<div class="DLabstract"><div style="display:inline"><p>Intelligent assistants are becoming widespread. A popular method for creating intelligent assistants is modeling the domain (and thus the assistant's capabilities) as Active Ontology. Adding new functionality requires extending the ontology or building new ones; as of today, this process is manual.</p> <p>We describe an automated method for creating Active Ontologies for arbitrary web forms. Our approach leverages methods from natural language processing and data mining to synthesize the ontologies. Furthermore, our tool generates the code needed to process user input.</p> <p>We evaluate the generated Active Ontologies in three case studies using web forms from the UIUC Web Integration Repository, namely from the domains airfare, automobile, and book search. First, we examine how much of the generation process can be automated and how well the approach identifies domain concepts and their relations. Second, we test how well the generated Active Ontologies handle end-user input to perform the desired actions. In our evaluation, E<scp>asier</scp> automatically generates 65% of the Active Ontologies' sensor nodes; the generated ontology for airfare search correctly answers 70% of the queries.</p></div> </div>
<h3>
<a class="DLtitleLink" href="https://urldefense.proofpoint.com/v2/url?u=https-3A__dl.acm.org_authorize-3FN652189&d=DwMFAg&c=clK7kQUTWtAVEOVIgvi0NU5BOUHhpN0H8p7CSfnc_gI&r=ZHuLpaRqk3Uz8lrvKUHs4g&m=91ndoZ1I-yPC2zXM6gqLhbohzFgiNgzLAyq0vrmbglM&s=_yP07EcJKjZP9pC7EQlIG8tbzFD355aFmO_As_phRjc&e=" title="Get the Full Text from the ACM Digital Library">Ways of applying artificial intelligence in software engineering</a>
</h3>
<ul class="DLauthors">
<li class="nameList First">Robert Feldt</li>
<li class="nameList">Francisco G. de Oliveira Neto</li>
<li class="nameList Last">Richard Torkar</li>
</ul>
<div class="DLabstract"><div style="display:inline"><p>As Artificial Intelligence (AI) techniques become more powerful and easier to use they are increasingly deployed as key components of modern software systems. While this enables new functionality and often allows better adaptation to user needs it also creates additional problems for software engineers and exposes companies to new risks. Some work has been done to better understand the interaction between Software Engineering and AI but we lack methods to classify ways of applying AI in software systems and to analyse and understand the risks this poses. Only by doing so can we devise tools and solutions to help mitigate them. This paper presents the AI in SE Application Levels (AI-SEAL) taxonomy that categorises applications according to their <i>point</i> of application, the type of AI <i>technology</i> used and the <i>automation level</i> allowed. We show the usefulness of this taxonomy by classifying 15 papers from previous editions of the RAISE workshop. Results show that the taxonomy allows classification of distinct AI applications and provides insights concerning the risks associated with them. We argue that this will be important for companies in deciding how to apply AI in their software applications and to create strategies for its use.</p></div> </div>
<h2>SESSION: Defect prediction</h2>
<div class="DLabstract"> </div>
<h3>
<a class="DLtitleLink" href="https://urldefense.proofpoint.com/v2/url?u=https-3A__dl.acm.org_authorize-3FN652180&d=DwMFAg&c=clK7kQUTWtAVEOVIgvi0NU5BOUHhpN0H8p7CSfnc_gI&r=ZHuLpaRqk3Uz8lrvKUHs4g&m=91ndoZ1I-yPC2zXM6gqLhbohzFgiNgzLAyq0vrmbglM&s=5Z8ZkpilhfDcixzbJhzi93Xzqcvnw5KIeJyflG3JymQ&e=" title="Get the Full Text from the ACM Digital Library">A replication study: just-in-time defect prediction with ensemble learning</a>
</h3>
<ul class="DLauthors">
<li class="nameList First">Steven Young</li>
<li class="nameList">Tamer Abdou</li>
<li class="nameList Last">Ayse Bener</li>
</ul>
<div class="DLabstract"><div style="display:inline"><p>Just-in-time defect prediction, which is also known as change-level defect prediction, can be used to efficiently allocate resources and manage project schedules in the software testing and debugging process. Just-in-time defect prediction can reduce the amount of code to review and simplify the assignment of developers to bug fixes. This paper reports a replicated experiment and an extension comparing the prediction of defect-prone changes using traditional machine learning techniques and ensemble learning. Using datasets from six open source projects, namely Bugzilla, Columba, JDT, Platform, Mozilla, and PostgreSQL we replicate the original approach to verify the results of the original experiment and use them as a basis for comparison for alternatives in the approach. Our results from the replicated experiment are consistent with the original. The original approach uses a combination of data preprocessing and a two-layer ensemble of decision trees. The first layer uses bagging to form multiple random forests. The second layer stacks the forests together with equal weights. Generalizing the approach to allow the use of any arbitrary set of classifiers in the ensemble, optimizing the weights of the classifiers, and allowing additional layers, we apply a new deep ensemble approach, called deep super learner, to test the depth of the original study. The deep super learner achieves statistically significantly better results than the original approach on five of the six projects in predicting defects as measured by <i>F</i><sub>1</sub> <i>score.</i></p></div> </div>
<h3>
<a class="DLtitleLink" href="https://urldefense.proofpoint.com/v2/url?u=https-3A__dl.acm.org_authorize-3FN652181&d=DwMFAg&c=clK7kQUTWtAVEOVIgvi0NU5BOUHhpN0H8p7CSfnc_gI&r=ZHuLpaRqk3Uz8lrvKUHs4g&m=91ndoZ1I-yPC2zXM6gqLhbohzFgiNgzLAyq0vrmbglM&s=oCLM7T6_uEV2XjJbkmezpLync9zVOYavK5izp2e9rVs&e=" title="Get the Full Text from the ACM Digital Library">Evaluating the adaptive selection of classifiers for cross-project bug prediction</a>
</h3>
<ul class="DLauthors">
<li class="nameList First">Dario Di Nucci</li>
<li class="nameList">Fabio Palomba</li>
<li class="nameList Last">Andrea De Lucia</li>
</ul>
<div class="DLabstract"><div style="display:inline"><p>Bug prediction models are used to locate source code elements more likely to be defective. One of the key factors influencing their performances is related to the selection of a machine learning method (a.k.a., classifier) to use when discriminating buggy and non-buggy classes. Given the high complementarity of stand-alone classifiers, a recent trend is the definition of <i>ensemble</i> techniques, which try to effectively combine the predictions of different stand-alone machine learners. In a recent work we proposed ASCI, a technique that dynamically selects the right classifier to use based on the characteristics of the class on which the prediction has to be done. We tested it in a within-project scenario, showing its higher accuracy with respect to the V<scp>alidation and</scp> V<scp>oting</scp> strategy. In this paper, we continue on the line of research, by (i) evaluating ASCI in a <i>global</i> and <i>local</i> cross-project setting and (ii) comparing its performances with those achieved by a stand-alone and an ensemble baselines, namely N<scp>aive</scp> B<scp>ayes</scp> and V<scp>alidation and</scp> V<scp>oting</scp>, respectively. A key finding of our study shows that ASCI is able to perform better than the other techniques in the context of cross-project bug prediction. Moreover, despite local learning is not able to improve the performances of the corresponding models in most cases, it is able to improve the robustness of the models relying on ASCI.</p></div> </div>
</div>
</div>
</body>
</html>
