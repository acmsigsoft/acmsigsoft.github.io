<html xmlns:bkstg="http://www.atypon.com/backstage-ns" xmlns:urlutil="java:com.atypon.literatum.customization.UrlUtil" xmlns:pxje="java:com.atypon.frontend.services.impl.PassportXslJavaExtentions">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
      <meta http-equiv="Content-Style-Type" content="text/css"><style type="text/css">
            #DLtoc {
            font: normal 12px/1.5em Arial, Helvetica, sans-serif;
            }

            #DLheader {
            }
            #DLheader h1 {
            font-size:16px;
            }

            #DLcontent {
            font-size:12px;
            }
            #DLcontent h2 {
            font-size:14px;
            margin-bottom:5px;
            }
            #DLcontent h3 {
            font-size:12px;
            padding-left:20px;
            margin-bottom:0px;
            }

            #DLcontent ul{
            margin-top:0px;
            margin-bottom:0px;
            }

            .DLauthors li{
            display: inline;
            list-style-type: none;
            padding-right: 5px;
            }

            .DLauthors li:after{
            content:",";
            }
            .DLauthors li.nameList.Last:after{
            content:"";
            }

            .DLabstract {
            padding-left:40px;
            padding-right:20px;
            display:block;
            }

            .DLformats li{
            display: inline;
            list-style-type: none;
            padding-right: 5px;
            }

            .DLformats li:after{
            content:",";
            }
            .DLformats li.formatList.Last:after{
            content:"";
            }

            .DLlogo {
            vertical-align:middle;
            padding-right:5px;
            border:none;
            }

            .DLcitLink {
            margin-left:20px;
            }

            .DLtitleLink {
            margin-left:20px;
            }

            .DLotherLink {
            margin-left:0px;
            }

        </style><title>A-TEST 2020: Proceedings of the 11th ACM SIGSOFT International Workshop on Automating TEST Case
         Design, Selection, and Evaluation
      </title>
   </head>
   <body>
      <div id="DLtoc">
         <div id="DLheader">
            <h1>A-TEST 2020: Proceedings of the 11th ACM SIGSOFT International Workshop on Automating TEST Case
               Design, Selection, and Evaluation
            </h1><a class="DLcitLink" title="Go to the ACM Digital Library for additional information about this proceeding" href="https://dl.acm.org/doi/proceedings/10.1145/3412452"><img class="DLlogo" alt="Digital Library logo" height="30" src="https://dl.acm.org/specs/products/acm/releasedAssets/images/footer-logo1.png">
               Full Citation in the ACM Digital Library
               </a></div>
         <div id="DLcontent">
            <h2>SESSION: Keynotes</h2>
            						
            <h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" href="https://dl.acm.org/doi/10.1145/3412452.3428119">SafeDNN: understanding and verifying neural networks (keynote)</a></h3>
            <ul class="DLauthors">
               <li class="nameList Last">Corina S. Păsăreanu</li>
            </ul>
            <div class="DLabstract">
               <div style="display:inline">
                  		
                  <p>The SafeDNN project at NASA Ames explores new techniques and tools to ensure that
                     systems that use Deep Neural Networks (DNN) are safe, robust and interpretable. Research
                     directions we are pursuing in this project include: symbolic execution for DNN analysis,
                     label-guided clustering to automatically identify input regions that are robust, parallel
                     and compositional approaches to improve formal SMT-based verification, property inference
                     and automated program repair for DNNs, adversarial training and detection, probabilistic
                     reasoning for DNNs. In this talk I will highlight some of the research advances from
                     SafeDNN.
                  </p>
                  	
               </div>
            </div>
            						
            					
            						
            <h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" href="https://dl.acm.org/doi/10.1145/3412452.3428120">The effectiveness of automated software testing techniques (keynote)</a></h3>
            <ul class="DLauthors">
               <li class="nameList Last">Aldeida Aleti</li>
            </ul>
            <div class="DLabstract">
               <div style="display:inline">
                  		
                  <p>With the rise of AI-based systems, such as self-driving&nbsp;cars, Google search, and automated
                     decision-making systems, new challenges&nbsp;have emerged for the testing community.&nbsp;Verifying
                     such software systems is becoming an extremely difficult and expensive task, often
                     constituting up to 90% of the software expenses.&nbsp;&nbsp;Software in a self-driving car,
                     for example, must safely operate in an infinite number of scenarios,&nbsp;which makes it
                     extremely hard to find bugs in such systems. In this talk, I will explore&nbsp;some of
                     these challenges, and introduce our work which aims at improving the bug-detection
                     capabilities of automated software testing. First, I will talk about a framework that
                     maps the effectiveness of automated software testing techniques, by identifying software
                     features that impact the ability&nbsp;of these techniques to achieve&nbsp;high code coverage.
                     Next, I will introduce our latest work that incorporates defect prediction information
                     to improve the efficiency&nbsp;of search-based software testing to detect software bugs.
                  </p>
                  	
               </div>
            </div>
            						
            					
            <h2>SESSION: Papers</h2>
            						
            <h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" href="https://dl.acm.org/doi/10.1145/3412452.3423570">Navigation and exploration in 3D-game automated play testing</a></h3>
            <ul class="DLauthors">
               <li class="nameList">I. S. W. B. Prasetya</li>
               <li class="nameList">Maurin Voshol</li>
               <li class="nameList">Tom Tanis</li>
               <li class="nameList">Adam Smits</li>
               <li class="nameList">Bram Smit</li>
               <li class="nameList">Jacco van Mourik</li>
               <li class="nameList">Menno Klunder</li>
               <li class="nameList">Frank Hoogmoed</li>
               <li class="nameList">Stijn Hinlopen</li>
               <li class="nameList">August van Casteren</li>
               <li class="nameList">Jesse van de Berg</li>
               <li class="nameList">Naraenda G.W.Y. Prasetya</li>
               <li class="nameList">Samira Shirzadehhajimahmood</li>
               <li class="nameList Last">Saba Gholizadeh Ansari</li>
            </ul>
            <div class="DLabstract">
               <div style="display:inline">
                  		
                  <p>To enable automated software testing, the ability to automatically navigate to a state
                     of interest and to explore all, or at least sufficient number of, instances of such
                     a state is fundamental. When testing a computer game the problem has an extra dimension,
                     namely the virtual world where the game is played on. This world often plays a dominant
                     role in constraining which logical states are reachable, and how to reach them. So,
                     any automated testing algorithm for computer games will inevitably need a layer that
                     deals with navigation on a virtual world. Unlike e.g. navigating through the GUI of
                     a typical web-based application, navigating over a virtual world is much more challenging.
                     This paper discusses how concepts from geometry and graph-based path finding can be
                     applied in the context of game testing to solve the problem of automated navigation
                     and exploration. As a proof of concept, the paper also briefly discusses the implementation
                     of the proposed approach.
                  </p>
                  	
               </div>
            </div>
            						
            					
            						
            <h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" href="https://dl.acm.org/doi/10.1145/3412452.3423571">Comparing transition trees test suites effectiveness for different mutation operators</a></h3>
            <ul class="DLauthors">
               <li class="nameList">Hoda Khalil</li>
               <li class="nameList Last">Yvan Labiche</li>
            </ul>
            <div class="DLabstract">
               <div style="display:inline">
                  		
                  <p>Research demonstrated that faults seeded mutation using operators can be representative
                     of faults in real systems. In this paper, we study the relationship between the different
                     operators used to insert mutants in the fault domain of the system under test and
                     the effectiveness of different state machine test suites at killing those mutants.
                     We are particularly interested in the effectiveness of two interrelated state machine
                     testing strategies at finding different types of faults. Those are the round-trip
                     paths strategy and the transition tree strategy. Using empirical evaluation, we compare
                     the effectiveness of more than two thousand unique test suites at killing mutants
                     seeded using eight different mutation operators. We perform experiments on four experimental
                     objects and provide qualitative analysis of the results. We conclude that neither
                     of the two studied strategies is more effective than the other at killing a certain
                     type of mutants. However, the structure of the finite state machine and the nature
                     of the system under test affect the type of faults detected by the different testing
                     strategies.
                  </p>
                  	
               </div>
            </div>
            						
            					
            						
            <h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" href="https://dl.acm.org/doi/10.1145/3412452.3423572">Fuzz4B: a front-end to AFL not only for fuzzing experts</a></h3>
            <ul class="DLauthors">
               <li class="nameList">Ryu Miyaki</li>
               <li class="nameList">Norihiro Yoshida</li>
               <li class="nameList">Natsuki Tsuzuki</li>
               <li class="nameList">Ryota Yamamoto</li>
               <li class="nameList Last">Hiroaki Takada</li>
            </ul>
            <div class="DLabstract">
               <div style="display:inline">
                  		
                  <p>In this tool demonstration paper, we propose a tool named Fuzz4B (Fuzzing for Beginner),
                     which is a front-end to a representative fuzzer AFL for developers who are inexperienced
                     in fuzz testing. Fuzz4B is not only a front-end, but it also allows developers to
                     reproduce a crash and minimize a fuzz that causes the crash. As a usage example, we
                     demonstrated the use of Fuzz4B to perform fuzz testing to discover a failure of an
                     open source library librope. Fuzz4B and its video are available at: &lt;a&gt;https://github.com/Ryu-Miyaki/Fuzz4B&lt;/a&gt;.
                  </p>
                  	
               </div>
            </div>
            						
            					
            						
            <h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" href="https://dl.acm.org/doi/10.1145/3412452.3423573">Towards automated testing of RPA implementations</a></h3>
            <ul class="DLauthors">
               <li class="nameList">Marina Cernat</li>
               <li class="nameList">Adelina Nicoleta Staicu</li>
               <li class="nameList Last">Alin Stefanescu</li>
            </ul>
            <div class="DLabstract">
               <div style="display:inline">
                  		
                  <p>Robotic Process Automation (RPA) is a technology that has grown tremendously in the
                     last years, due to its usability in the area of process automation. An essential part
                     of any software development process is quality assurance, so testing will be very
                     important for RPA processes. However, the classical software techniques are not always
                     suitable for the RPA software robots due to the mix of the graphical description of
                     the robots and their implementations. In this short paper, we describe the state of
                     the practice for testing of software robots and propose some ideas of test automation
                     using model-based testing.
                  </p>
                  	
               </div>
            </div>
            						
            					
         </div>
      </div>
   </body>
</html>